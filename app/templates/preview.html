# Em seu arquivo routes.py

@main_routes.route('/import_planilha', methods=['POST'])
def import_planilha():
    try:
        if request.content_length > TAMANHO_MAXIMO:
            logger.warning(f"Tentativa de upload de arquivo muito grande: {request.content_length} bytes")
            return jsonify({"success": False, "msg": "Arquivo muito grande (máx. 5MB)"}), 400

        file = request.files.get('planilha')
        empresa = request.form.get('empresa', '').lower()

        if not file or not empresa:
            return jsonify({"success": False, "msg": "Arquivo ou empresa não especificados"}), 400
        if not arquivo_seguro(file):
            return jsonify({"success": False, "msg": "Tipo de arquivo não permitido ou inválido"}), 400

        # --- PONTO CHAVE DA CORREÇÃO ---
        # Filtra a lista atual, mantendo apenas os itens que NÃO são do tipo da empresa que estamos importando.
        # Isso efetivamente "limpa" os dados antigos daquela origem antes de adicionar os novos.
        lista_atual = [item for item in session.get('lista', []) if item.get('importacao_tipo') != empresa]
        logger.info(f"Lista após limpar a origem '{empresa}': {len(lista_atual)} itens.")

        novos_itens_importados = []

        # O resto do código da função para ler Delnext e Paack continua igual...
        # ... (código de leitura do pandas para Delnext)
        if empresa == "delnext":
            file.seek(0)
            filename = file.filename.lower()
            
            if filename.endswith(('.xlsx', '.xls')):
                df = pd.read_excel(file, header=1)
            elif filename.endswith(('.csv', '.txt')):
                try:
                    content = file.read().decode('utf-8')
                    dialect = csv.Sniffer().sniff(content.splitlines()[0], delimiters=[',', ';'])
                    file.seek(0)
                    df = pd.read_csv(io.StringIO(content), header=1, sep=dialect.delimiter)
                except Exception:
                    file.seek(0)
                    df = pd.read_csv(file, header=1, sep=';')
            else:
                return jsonify({"success": False, "msg": "Formato Delnext não suportado."}), 400
            
            if df.empty:
                return jsonify({"success": False, "msg": "Planilha Delnext vazia ou em formato inválido."}), 400

            df.columns = df.columns.astype(str)
            col_morada = next((c for c in df.columns if 'morada' in c.lower()), None)
            col_cep = next((c for c in df.columns if 'código postal' in c.lower() or 'codigo postal' in c.lower()), None)
            
            if not col_morada or not col_cep:
                return jsonify({"success": False, "msg": "Colunas 'Morada' ou 'Código Postal' não encontradas no arquivo Delnext."}), 400

            for index, row in df.iterrows():
                endereco = str(row[col_morada]).strip()
                cep = str(row[col_cep]).strip()
                
                if not endereco or not cep: continue
                    
                cep = re.sub(r'[^\d-]', '', cep)
                if len(cep) == 7 and '-' not in cep: cep = f"{cep[:4]}-{cep[4:]}"
                if len(cep) == 8 and '-' not in cep: cep = f"{cep[:4]}-{cep[4:]}"

                res_google = valida_rua_google_cache(endereco, cep)
                rua_digitada = endereco.split(',')[0]
                rua_google = res_google.get('route_encontrada', '')
                
                novo = {
                    "order_number": "", "address": endereco, "cep": cep,
                    "status_google": res_google.get('status'),
                    "postal_code_encontrado": res_google.get('postal_code_encontrado', ''),
                    "endereco_formatado": res_google.get('endereco_formatado', ''),
                    "latitude": res_google.get('coordenadas', {}).get('lat', ''),
                    "longitude": res_google.get('coordenadas', {}).get('lng', ''),
                    "rua_google": rua_google,
                    "cep_ok": cep == res_google.get('postal_code_encontrado', ''),
                    "rua_bate": (normalizar(rua_digitada) in normalizar(rua_google) or normalizar(rua_google) in normalizar(rua_digitada)),
                    "freguesia": res_google.get('sublocality', ''),
                    "importacao_tipo": "delnext", "cor": cor_por_tipo("delnext")
                }
                if registro_unico(lista_atual + novos_itens_importados, novo):
                    novos_itens_importados.append(novo)

        # ... (código de leitura do pandas para Paack)
        elif empresa == "paack":
            file.seek(0)
            df = pd.read_excel(file, header=0) # Assumindo header na primeira linha para Paack
            df.columns = df.columns.astype(str)
            col_end = next((c for c in df.columns if 'endereco' in c.lower()), None)
            col_cep = next((c for c in df.columns if 'cep' in c.lower()), None)

            if not col_end or not col_cep:
                return jsonify({"success": False, "msg": "Colunas 'Endereco' ou 'CEP' não encontradas no arquivo Paack."}), 400

            for index, row in df.iterrows():
                endereco = str(row[col_end]).strip()
                cep = str(row[col_cep]).strip()
                if not endereco or not cep: continue

                cep = re.sub(r'[^\d-]', '', cep)
                if len(cep) == 7 and '-' not in cep: cep = f"{cep[:4]}-{cep[4:]}"

                res_google = valida_rua_google_cache(endereco, cep)
                rua_digitada = endereco.split(',')[0]
                rua_google = res_google.get('route_encontrada', '')
                
                novo = {
                    "order_number": "", "address": endereco, "cep": cep,
                    "status_google": res_google.get('status'),
                    "postal_code_encontrado": res_google.get('postal_code_encontrado', ''),
                    "endereco_formatado": res_google.get('endereco_formatado', ''),
                    "latitude": res_google.get('coordenadas', {}).get('lat', ''),
                    "longitude": res_google.get('coordenadas', {}).get('lng', ''),
                    "rua_google": rua_google,
                    "cep_ok": cep == res_google.get('postal_code_encontrado', ''),
                    "rua_bate": (normalizar(rua_digitada) in normalizar(rua_google) or normalizar(rua_google) in normalizar(rua_digitada)),
                    "freguesia": res_google.get('sublocality', ''),
                    "importacao_tipo": "paack", "cor": cor_por_tipo("paack")
                }
                if registro_unico(lista_atual + novos_itens_importados, novo):
                    novos_itens_importados.append(novo)
        else:
            return jsonify({"success": False, "msg": "Empresa não suportada"}), 400
        
        # O resto do código para reatribuir order_numbers continua igual...
        lista_atual.extend(novos_itens_importados)

        manual_counter = 0; delnext_counter = 0; paack_counter = 0
        for item in lista_atual:
            order_num_str = str(item.get('order_number', ''))
            try:
                if item.get('importacao_tipo') == 'manual' and order_num_str.isdigit():
                    manual_counter = max(manual_counter, int(order_num_str))
                elif item.get('importacao_tipo') == 'delnext' and order_num_str.startswith('D') and order_num_str[1:].isdigit():
                    delnext_counter = max(delnext_counter, int(order_num_str[1:]))
                elif item.get('importacao_tipo') == 'paack' and order_num_str.startswith('P') and order_num_str[1:].isdigit():
                    paack_counter = max(paack_counter, int(order_num_str[1:]))
            except (ValueError, TypeError): pass
        
        for item in lista_atual:
            needs_reindex = not item.get('order_number')
            if not needs_reindex:
                if item.get('importacao_tipo') == 'manual' and not str(item.get('order_number')).isdigit(): needs_reindex = True
                elif item.get('importacao_tipo') == 'delnext' and not str(item.get('order_number')).startswith('D'): needs_reindex = True
                elif item.get('importacao_tipo') == 'paack' and not str(item.get('order_number')).startswith('P'): needs_reindex = True
            
            if needs_reindex:
                if item.get('importacao_tipo') == 'manual':
                    manual_counter += 1; item['order_number'] = str(manual_counter)
                elif item.get('importacao_tipo') == 'delnext':
                    delnext_counter += 1; item['order_number'] = f"D{delnext_counter}"
                elif item.get('importacao_tipo') == 'paack':
                    paack_counter += 1; item['order_number'] = f"P{paack_counter}"
        
        session['lista'] = lista_atual
        session.modified = True
        logger.info(f"Importação concluída. Total de itens na sessão: {len(lista_atual)}.")
        
        return jsonify({ "success": True, "lista": lista_atual })

    except Exception as e:
        logger.error(f"Erro geral na importação: {str(e)}", exc_info=True)
        return jsonify({"success": False, "msg": f"Erro na importação: {str(e)}"}), 500
